# 前缀和

一般来说，前缀和是处理数组中的一段数据的和，并且数据量是比较大的，如果按照直接循环遍历的方法来做，会有log（n）的复杂度，而使用前缀和的方法查询的复杂度只有log（1）。

**什么是前缀和？**

```c++
有一个数组 num =  [1,2,3,4,5,6,7,8,9]
我们记录 s1 = num[1], s2 = num[1] + num[2],s3 = num[1] + num[2] + num[3],
以此类推：si = num[1] + num[2] + num[3] + ... + num[i]

所以当我们计算，数组中第1个到第4个数的和时，我们只需 s4 - s0 就行，不需要一个一个遍历
时间复杂度也只是遍历一遍原来数组的大小，属于是空间换时间了！
```



**下面看一道例题**

**题目描述：**

输入一个长度为 n 的整数序列。

接下来再输入 mm 个询问，每个询问输入一对 l,r。

对于每个询问，输出原序列中从第 l 个数到第 r 个数的和



**输入格式：**

第一行包含两个整数 n 和 m。

第二行包含 n 个整数，表示整数数列。

接下来 mm 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。



**输出格式：**
共 m 行，每行输出一个询问的结果。



**数据范围：**
1 ≤ l ≤ r ≤n
1 ≤ n,m ≤ 100000
−1000 ≤ 数列中元素的值 ≤ 1000



**输入样例：**

```c++
5 3
2 1 3 6 4
1 2
1 3
2 4
```



**输出样例：**

```c++
3
6
10
```





**AC代码：**

```c++
#include <iostream>
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int num[N],res[N];
int n,m;

int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= n; i++)	scanf("%d",&num[i]);
	
	for(int i = 1; i <= n; i++)	res[i] = res[i - 1] + num[i];
	
	while(m--){
		int l,r;
		cin >> l >> r;
		cout << res[r] - res[l - 1] << endl;
	}
	
}
```

