# 1. 递归实现指数型枚举

**题目描述**：

给定一个长度为 n 的可包含重复数字的序列，从中随机选取任意多个数字，输出所有可能的选择方案。

**输入格式**：

第一行包含一个整数 n，表示序列长度。

第二行包含 n 个正整数。

**输出格式**：

每行输出一种方案。

同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。

对于没有选任何数的方案，输出空行。

本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。

**数据范围**：

1 ≤ n ≤ 15
序列内所有元素均不大于 n。

**输入样例**：

```
3
1 2 2
```

**输出样例**：

```
1
2
1 2
2 2
1 2 2
```



**思路：**

这是最基本的递归模板题，在考虑递归枚举的时候，就是要选出一种不重不漏的方案能够枚举出所有的情况。并且递归枚举的问题都可以抽象出一颗树。

我们只需要考虑每一个位置选不选，然后画出简单的递归搜索树就行。

注意的就是会有重复的选择，所以我们在选择的时候，如果当前位置的数和前一个位置的数相等，并且前一个位置的数已经选过了，当前位置的数就不能在选择了。

![image-20220617133914145](C:\Users\19241\AppData\Roaming\Typora\typora-user-images\image-20220617133914145.png)

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 16;
int n;
int num[N];
bool vis[N];

void dfs(int s)
{
    if(s == n){
        for(int i = 0; i < n; i++){
            if(vis[i])  cout << num[i] << ' ';
        }
        cout << endl;
        
        return;
    }
    
    vis[s] = true;
    dfs(s + 1);
    
    //如果当前位置的数和前一个位置的数相同，且前一个数已经使用过，就不要再当使用当前位置的数了
    if(vis[s - 1] && num[s] == num[s - 1])  return; 
    
    vis[s] = false;
    dfs(s + 1);
}
int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)  cin >> num[i];
    
    sort(num, num + n);
    
    dfs(0);
    
    return 0;
}
```

